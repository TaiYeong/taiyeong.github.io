---
author: taiyeong.song
category: pipeline
layout: post
title: C++ sysntax
---

## C++ 9 characteristic

Modern C++ introduces various improvements and new features to enhance both performance and code readability. Let's break down some key aspects of modern C++ syntax, starting with a few major updates from C++11 and onwards:

- 1. Auto Keyword  
    - The `auto` keyword allows the compiler to automatically deduce the type of a variable at compile time.

    ```cpp
    auto x = 10;     // int
    auto y = 3.14;   // double
    auto str = "Hello";  // const char*
    ```

- 2. Range-Based For Loop
    - C++11 introduced range-based for loops to simplify iterating through collections.

    ```cpp
    std::vector<int> v = {1, 2, 3, 4, 5};
    for (auto elem : v) {
        std::cout << elem << std::endl;
    }
    ```

- 3. Lambda Expressions  
    - Lambda expressions enable inline functions, useful for short, unnamed functions.

    ```cpp
    auto sum = [](int a, int b) {
        return a + b;
    };
    std::cout << sum(5, 3);  // Outputs 8
    ```

- 4. Smart Pointers
    - Smart pointers manage the lifecycle of dynamically allocated objects automatically.

    - types
        - `std::unique_ptr`: Ensures exclusive ownership.
        - `std::shared_ptr`: Allows multiple ownership.
        - `std::weak_ptr`: Non-owning reference to an object managed by `std::shared_ptr`.

        ```cpp
        std::unique_ptr<int> ptr = std::make_unique<int>(42);
        std::shared_ptr<int> sharedPtr = std::make_shared<int>(10);
        ```

-5. Move Semantics and `std::move`
    - Move semantics allow resources (e.g., memory) to be transferred rather than copied.

    ```cpp
    std::vector<int> v1 = {1, 2, 3};
    std::vector<int> v2 = std::move(v1);  // v1 is now empty, and v2 takes over the data
    ```

- 6. constexpr
    - The `constexpr` keyword allows the evaluation of functions or variables at compile time.

    ```cpp
    constexpr int square(int x) {
        return x * x;
    }
    constexpr int result = square(5);  // Computed at compile time
    ```

- 7. Structured Bindings (C++17)
    - This feature allows you to unpack tuples, pairs, or structs into multiple variables.

    ```cpp
    std::pair<int, double> p = {1, 2.5};
    auto [x, y] = p;  // x = 1, y = 2.5
    ```

- 8. std::optional (C++17)
    - `std::optional` represents a value that may or may not be present.

    ```cpp
    std::optional<int> maybeInt;
    if (maybeInt) {
        std::cout << *maybeInt;
    }
    ```

- 9. Type Traits and `std::enable_if`  
    - Type traits and SFINAE allow template metaprogramming, enabling or disabling certain functions based on type conditions.

    ```cpp
    template <typename T>
    typename std::enable_if<std::is_integral<T>::value>::type
    printIfInt(T t) {
        std::cout << "Integer: " << t << std::endl;
    }
    ```




## Varaible initialization

C++ offers several ways to initialize variables, with each style evolving over different versions of the language. These initializations cover different data types, from primitive types to user-defined objects. Here's an overview of the key types of initialization in C++:

- 1. Copy Initialization

    - This is the simplest and oldest form of initialization in C++. It uses the assignment operator (`=`) to initialize a variable.

    ```cpp
    int x = 10;             // Primitive type
    std::string str = "Hello";  // Class type (std::string)
    ```

    - **How it works**: The object is constructed first and then assigned a value. This can invoke a copy constructor (for objects).

- 2. Direct Initialization

    - In this form, the variable is initialized directly using parentheses. It's more efficient for class types because it avoids the extra step of copy assignment.

    ```cpp
    int x(10);                // Primitive type
    std::string str("Hello");  // Class type (std::string)
    ```

    - **How it works**: The object is constructed directly with the specified value, potentially calling a constructor for objects.

- 3. List Initialization (C++11)
    - Also known as *uniform initialization*, this was introduced in C++11. It uses curly braces `{}` to initialize variables.

    - a) **Braced Initialization (Direct List Initialization)**

    ```cpp
    int x{10};                // Primitive type
    std::string str{"Hello"};  // Class type (std::string)
    ```

    - b) **Aggregate Initialization**

        - For initializing aggregate types (like arrays or structs), you can use brace initialization.

        ```cpp
        std::array<int, 3> arr = {1, 2, 3};  // Array initialization
        ```

    - c) **Initializer List (std::initializer_list)**

        - Classes can be initialized with a list of values by providing an initializer list constructor.

        ```cpp
        std::vector<int> vec = {1, 2, 3, 4, 5};  // Uses std::initializer_list
        ```

    - **Advantages**:  
        - Prevents **narrowing conversions** (e.g., floating point to integer conversions).
        - Offers consistent syntax for initializing different types of objects.
        - Reduces ambiguity and potential errors in initialization.

- 4. Default Initialization

    - When a variable is declared but not explicitly initialized, it undergoes default initialization.

    ```cpp
    int x;  // x is uninitialized (may contain garbage value)
    std::string str;  // Default constructor is called; str is an empty string
    ```

    - **Primitive types**: Local primitive types are left uninitialized.
    - **Objects**: Objects are initialized via their default constructors.

- 5. Value Initialization

    - This is where a variable is initialized to a zero or equivalent default value. For objects, it calls the default constructor, and for primitive types, it initializes them to zero.

    - a) **For Primitive Types**

    ```cpp
    int x{};   // Zero-initialization: x is 0
    ```

    - b) **For User-Defined Types**

    ```cpp
    std::string str{};  // Default-initialized as an empty string
    ```

    - **When it's used**: When you use empty braces (`{}`) or parentheses `()` to initialize a variable, the variable is value-initialized.

- 6. Zero Initialization

    - When variables are zero-initialized, their values are explicitly set to zero (for built-in types) or default-initialized (for user-defined types).

    - **Zero-initialization occurs** when variables are declared as static, as globals, or as members of a class with no constructors. For example:

    ```cpp
    static int x;  // x is zero-initialized to 0
    ```

- 7. Move Initialization (C++11)

    - Move initialization occurs when you use `std::move` to transfer ownership of resources (typically from an object that is no longer needed).

    ```cpp
    std::vector<int> vec1 = {1, 2, 3};
    std::vector<int> vec2 = std::move(vec1);  // Moves vec1's resources to vec2
    ```

    - **When to use**: When the object you're moving from is no longer needed, so its contents can be transferred rather than copied.

- 8. Reference Initialization

    - References must be initialized when declared, and they reference an existing variable. A reference cannot be re-assigned once it is initialized.

    ```cpp
    int x = 10;
    int& ref = x;  // ref is a reference to x
    ```

    - **Note**: `const` references can bind to temporary objects (rvalues).

- 9. Pointer Initialization

    - Pointers can be initialized to null or point to a valid memory address.

    ```cpp
    int* ptr = nullptr;   // C++11 nullptr
    int* ptr2 = &x;       // Pointer to x
    ```

---

### **Summary Table**

| **Initialization Type**       | **Syntax Example**                         | **Description**                                                                 |
|-------------------------------|--------------------------------------------|---------------------------------------------------------------------------------|
| **Copy Initialization**        | `int x = 10;`                              | Assignment-style initialization; may invoke copy constructor.                   |
| **Direct Initialization**      | `int x(10);`                               | Directly initializes the variable, often more efficient for objects.            |
| **List Initialization**        | `int x{10};` or `std::vector<int> v{1,2};` | Uses curly braces `{}`; prevents narrowing conversions.                         |
| **Default Initialization**     | `int x;`                                   | No explicit initialization; may result in garbage values for primitive types.   |
| **Value Initialization**       | `int x{};`                                 | Initializes primitive types to zero; calls default constructors for objects.    |
| **Zero Initialization**        | `static int x;`                            | Sets primitive types to zero, or calls default constructors.                    |
| **Move Initialization**        | `std::move(obj)`                           | Transfers ownership of resources from one object to another.                    |
| **Reference Initialization**   | `int& ref = x;`                            | Initializes a reference to refer to an existing variable.                       |
| **Pointer Initialization**     | `int* ptr = nullptr;`                      | Initializes a pointer; often initialized with `nullptr`.                        |

---

## Various loop

### 1. `for` Loop
- The `for` loop is used when you know in advance how many times you want to iterate through the block of code. It consists of three parts: initialization, condition, and increment/decrement.

- Syntax:
    ```cpp
    for (initialization; condition; increment) {
        // Code to be executed
    }
    ```

#### Example:
    ```cpp
    for (int i = 0; i < 5; ++i) {
        std::cout << i << " ";  // Output: 0 1 2 3 4
    }
    ```

- **Use Case**: Best for situations where the number of iterations is known beforehand (e.g., looping over arrays, vectors with known size).

### 2. `while` Loop
- The `while` loop is used when the number of iterations is not known, and you want to loop until a condition becomes false.

- Syntax:
    ```cpp
    while (condition) {
        // Code to be executed
    }
    ```

- Example:
    ```cpp
    int i = 0;
    while (i < 5) {
        std::cout << i << " ";  // Output: 0 1 2 3 4
        ++i;
    }
    ```

- **Use Case**: Best when you want to loop based on some condition that could change during execution (e.g., waiting for user input, reading from a file).


### 3. Range-Based `for` Loop (C++11 and Later)
- The range-based `for` loop simplifies iteration over containers (like arrays, vectors, lists). It automatically handles the iterator behind the scenes.

- Syntax:
    ```cpp
    for (element_type variable : collection) {
        // Code to be executed
    }
    ```

- Example:
    ```cpp
    std::vector<int> vec = {1, 2, 3, 4, 5};
    for (int elem : vec) {
        std::cout << elem << " ";  // Output: 1 2 3 4 5
    }
    ```

- **Use Case**: Best for iterating over containers (arrays, vectors, lists) in a cleaner, more readable way.




### Comparison Table

| **Loop Type**          | **Syntax Example**                                     | **When to Use**                                                                |
|------------------------|--------------------------------------------------------|--------------------------------------------------------------------------------|
| **`for` loop**          | `for (int i = 0; i < N; ++i)`                          | Known number of iterations, concise control over loop index.                   |
| **`while` loop**        | `while (condition)`                                    | Unknown number of iterations, condition checked before entering the loop.       |
| **Range-based `for`**   | `for (auto elem : collection)`                         | Clean, efficient way to iterate over containers (arrays, vectors, lists, etc.). |

---

## Pointer -----------------

ì¢‹ì€ ì£¼ì œì˜ˆìš”!
C++ì—ì„œ \*\*í¬ì¸í„°(pointer)\*\*ì™€ \*\*ì°¸ì¡°(reference)\*\*ëŠ” ëª¨ë‘ **ë‹¤ë¥¸ ë©”ëª¨ë¦¬ ì£¼ì†Œë¥¼ í†µí•´ ê°’ì„ ì¡°ì‘í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” ë„êµ¬**ì§€ë§Œ, ë¬¸ë²•ê³¼ ê°œë…, ì“°ì„ìƒˆ ë©´ì—ì„œ ì¤‘ìš”í•œ ì°¨ì´ê°€ ìˆì–´ìš”.

---

## í¬ì¸í„°(pointer) vs ì°¸ì¡°(reference) 

- ìš”ì•½ 

| í•­ëª©             | í¬ì¸í„° (`T* ptr`)             | ì°¸ì¡° (`T& ref`)       |
| -------------- | -------------------------- | ------------------- |
| ì„ ì–¸ ì‹œ ì´ˆê¸°í™”       | ì„ íƒ ì‚¬í•­ (null í—ˆìš©)            | ë°˜ë“œì‹œ ì´ˆê¸°í™”í•´ì•¼ í•¨         |
| null ê°€ëŠ¥ì„±       | âœ… `nullptr` ê°€ëŠ¥             | âŒ í•­ìƒ ìœ íš¨í•œ ê°ì²´ë¥¼ ê°€ë¦¬ì¼œì•¼ í•¨ |
| ë³€ê²½ ê°€ëŠ¥ì„± (ë‹¤ë¥¸ ëŒ€ìƒ) | âœ… ë‹¤ë¥¸ ì£¼ì†Œë¡œ ë³€ê²½ ê°€ëŠ¥             | âŒ í•œ ë²ˆ ë°”ì¸ë”©ë˜ë©´ ëŒ€ìƒ ê³ ì •   |
| ê°„ì ‘ ì ‘ê·¼          | `*ptr`, `ptr->`            | ê·¸ëƒ¥ `ref` ì‚¬ìš©         |
| ë°°ì—´/ë™ì  í• ë‹¹ê³¼ì˜ ê¶í•©  | ë§¤ìš° ì¢‹ìŒ (`new[]`, `malloc`)  | ì í•©í•˜ì§€ ì•ŠìŒ             |
| ë©”ëª¨ë¦¬ ì£¼ì†Œ í‘œì‹œ      | `&x`, `*ptr`, `ptr++` ë“± ë‹¤ì–‘ | ì£¼ì†Œë¥¼ ì§ì ‘ ë‹¤ë£¨ì§„ ì•ŠìŒ       |
| í•¨ìˆ˜ ì¸ìë¡œ ì‚¬ìš©      | ê°’ ìì²´ë¥¼ ë°”ê¾¸ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©          | ë™ì¼ ëª©ì , ë” ì§ê´€ì ì´ê³  ì•ˆì „   |
| ì»¨í…Œì´ë„ˆ iterator  | ëŒ€ë¶€ë¶„ í¬ì¸í„° ê¸°ë°˜                 | ì°¸ì¡°ëŠ” ë¶ˆê°€ëŠ¥             |

- âœ… ì˜ˆì œ ë¹„êµ
    - ê²°ê³¼ëŠ” ê°™ì§€ë§Œ ë¬¸ë²•ì€ ê°„ê²°í•˜ê²Œ ë‹¤ë¦„.
    
    -ğŸ”· í¬ì¸í„° ì˜ˆì œ

    ```cpp
    int a = 10;
    int* ptr = &a;

    *ptr = 20;  // aì˜ ê°’ì´ 20ìœ¼ë¡œ ë°”ë€œ
    ```

    - ğŸ”· ì°¸ì¡° ì˜ˆì œ

    ```cpp
    int a = 10;
    int& ref = a;

    ref = 20;  // aì˜ ê°’ì´ 20ìœ¼ë¡œ ë°”ë€œ
    ```



---

- í•¨ìˆ˜ ì¸ì ì „ë‹¬ ì˜ˆ

    - ì°¸ì¡° ë°©ì‹ì´ ë” **ê°„ê²°í•˜ê³  ì•ˆì „í•˜ë©°**, ì‹¤ì œ ê°’ì´ ë°”ë€ŒëŠ” ê²ƒì´ ëª…í™•í•˜ê²Œ ë³´ì…ë‹ˆë‹¤.

    - ğŸ”· í¬ì¸í„° ë°©ì‹

    ```cpp
    void setZero(int* p) {
        *p = 0;
    }

    int main() {
        int x = 5;
        setZero(&x);  // ì£¼ì†Œ ì „ë‹¬
    }
    ```

    - ğŸ”· ì°¸ì¡° ë°©ì‹

    ```cpp
    void setZero(int& r) {
        r = 0;
    }

    int main() {
        int x = 5;
        setZero(x);  // ë³€ìˆ˜ ê·¸ëŒ€ë¡œ ì „ë‹¬
    }
    ```

- ì£¼ìš” íŠ¹ì§• ìš”ì•½

| ê¸°ëŠ¥       | í¬ì¸í„°              | ì°¸ì¡°                |
| -------- | ---------------- | ----------------- |
| ëŒ€ìƒ ë³€ê²½ ê°€ëŠ¥ | âœ… (ë‹¤ë¥¸ ì£¼ì†Œ í• ë‹¹ ê°€ëŠ¥)  | âŒ (ì´ˆê¸° ëŒ€ìƒ ê³ ì •)      |
| null ìƒíƒœ  | âœ… `nullptr` ê°€ëŠ¥   | âŒ null ì—†ìŒ         |
| ì—­ì°¸ì¡° í•„ìš”   | âœ… `*ptr`         | âŒ `ref` ìì²´ê°€ ì§ì ‘ ëŒ€ìƒ |
| í•¨ìˆ˜ ì¸ì ì „ë‹¬ | ë³´í†µ C ìŠ¤íƒ€ì¼         | C++ì—ì„œ ì„ í˜¸          |
| ì•ˆì „ì„±      | âŒ ì‹¤ìˆ˜ë¡œ null ì ‘ê·¼ ìœ„í—˜ | âœ… ì•ˆì „í•˜ê³  ê¹”ë”         |
| ì‚¬ìš© ì˜ˆ     | ë°°ì—´ ì²˜ë¦¬, ë™ì  ë©”ëª¨ë¦¬    | í•¨ìˆ˜ ì¸ì, ë°˜í™˜ê°’ ë“±      |

---

### ì–¸ì œ í¬ì¸í„°ë¥¼ ì¨ì•¼ í• ê¹Œ?

- **ë™ì  í• ë‹¹** (`new`, `malloc`)
- **ë°°ì—´ ì²˜ë¦¬** (`T* arr`)
- **ë°ì´í„° ì¡´ì¬ ì—¬ë¶€ê°€ optionalì¼ ë•Œ** (`nullptr` í—ˆìš©)
- **ê°ì²´ì˜ ì†Œìœ ê¶Œ, ìƒëª… ì£¼ê¸° ì»¨íŠ¸ë¡¤ì´ í•„ìš”í•œ ê²½ìš°**
- **C API ì—°ë™**

---

### ì–¸ì œ ì°¸ì¡°ë¥¼ ì¨ì•¼ í• ê¹Œ?

- **ì¸ì ê°’ ë³€ê²½ì´ í•„ìš”í•˜ì§€ë§Œ, ë” ì•ˆì „í•˜ê³  ì§ê´€ì ì¸ ë¬¸ë²•ì„ ì›í•  ë•Œ**
- **ëŒ€ìƒì´ ë°˜ë“œì‹œ ì¡´ì¬í•˜ëŠ” ê²½ìš°**
- **í•¨ìˆ˜ ë°˜í™˜ê°’ì„ ì›ë³¸ê³¼ ì—°ê²°ì‹œí‚¤ê³  ì‹¶ì„ ë•Œ**
- **C++ ìŠ¤íƒ€ì¼ ì½”ë“œ ì‘ì„± ì‹œ ê¸°ë³¸ê°’ì²˜ëŸ¼ ì‚¬ìš©**

---

### ğŸ§  í•œ ì¤„ ìš”ì•½

> ì°¸ì¡°ëŠ” **ê°„ë‹¨í•˜ê³  ì•ˆì „í•œ í¬ì¸í„°ì²˜ëŸ¼** ì‘ë™í•˜ê³ ,
> í¬ì¸í„°ëŠ” **ë” ìœ ì—°í•˜ì§€ë§Œ ìœ„í—˜ ë¶€ë‹´ì´ ìˆëŠ” ë©”ëª¨ë¦¬ ë„êµ¬**ì˜ˆìš”.




## Pointer and Array

### Basic

```cpp
    int real_val = 5;
    int *p_int_val = &real_val;
    *p_int_val // 5
    p_int_val // address of real_val
    &real_val // address of real_val

    int int_array[] = {1,2,3,4,5};
    int *p_int_array = int_array;

    int_array // address of the first index of int_array array
```

## Array / List / Vector

### 1. Array
- **Type:** Fixed-size, contiguous block of memory.
- **Syntax:**  
  ```cpp
  int arr[5] = {1, 2, 3, 4, 5};
  ```
- **Key Characteristics:**
  - **Fixed size:** The size is determined at compile-time and cannot be changed.
  - **Memory layout:** Stored contiguously in memory, which makes access to elements very fast (O(1) for access).
  - **No dynamic resizing:** You cannot add or remove elements after the array is created.
  - **No overhead:** Arrays are simple and have no extra memory overhead compared to lists or vectors.
  - **No safety checks:** Accessing out-of-bounds elements leads to undefined behavior.

- **Use Case:** Best for situations where the size of the array is known beforehand and doesn't change, and fast access to elements is important (e.g., low-level programming, embedded systems).

### 2. List (`std::list`)
- **Type:** Doubly linked list.
- **Syntax:**  
  ```cpp
  std::list<int> lst = {1, 2, 3, 4, 5};
  ```

- **Key Characteristics:**
  - **Dynamic size:** The size can grow or shrink as elements are inserted or removed.
  - **Non-contiguous memory:** Elements are not stored in contiguous memory, and each element points to the next and previous elements. This makes accessing elements slower (O(n) for access).
  - **Efficient insertions/removals:** Inserting or removing elements (except at the end) is O(1) because only pointers need to be updated.
  - **Memory overhead:** Each element requires extra memory for the pointers to the next and previous elements.
  
- **Use Case:** Suitable when frequent insertions and deletions are required in the middle of the collection, but fast random access is not necessary (e.g., implementing queues, managing large datasets where resizing is needed).

### 3. Vector (`std::vector`)
- **Type:** Dynamic array.
- **Syntax:**  
  ```cpp
  std::vector<int> vec = {1, 2, 3, 4, 5};
  ```

- **Key Characteristics:**
  - **Dynamic size:** The size can grow dynamically as new elements are added.
  - **Contiguous memory:** Elements are stored in contiguous memory blocks, similar to arrays, which makes access very fast (O(1) for access).
  - **Resizing:** When the vector runs out of capacity, it reallocates more memory (typically doubling the capacity), which involves copying elements to a new memory block.
  - **Efficient access:** Accessing elements is fast (O(1)), but insertions and deletions in the middle or beginning can be slow (O(n)) due to shifting of elements.
  - **Memory overhead:** When reallocating memory, some extra capacity is allocated to avoid frequent reallocations, which adds a small memory overhead.

- **Use Case:** Best when the size of the collection changes dynamically, and fast access to elements is important (e.g., dynamic arrays, stacks, dynamic lists).

---

### **Comparison Table**

| Feature              | **Array**            | **List (`std::list`)** | **Vector (`std::vector`)** |
|----------------------|----------------------|------------------------|----------------------------|
| **Size**             | Fixed at compile-time| Dynamic                | Dynamic                    |
| **Memory Layout**    | Contiguous           | Non-contiguous         | Contiguous                 |
| **Element Access**   | O(1) (Direct)        | O(n) (Sequential)      | O(1) (Direct)              |
| **Insert/Remove (Start/Middle)** | O(n)              | O(1)                   | O(n)                       |
| **Insert/Remove (End)** | O(1)              | O(1)                   | O(1)                       |
| **Resizing**         | Not possible         | Automatic              | Automatic (with reallocation) |
| **Memory Overhead**  | None                 | High (pointers)        | Low (extra capacity)       |

---

### **Summary:**
- **Array**: Use when you know the size of the collection upfront and need fast access to elements.
- **List**: Use when frequent insertions/deletions are needed, especially in the middle or beginning of the collection.
- **Vector**: Use when you need a dynamic size but still want fast random access.

If you want to explore code examples or specific performance metrics, let me know!

## Various array initialization
![LenSummary](../assets/cpp_array_init_001.png)

### 1. Static Array

```cpp
    // 1. Initialize array with 5 elements
    int arr[5] = {1, 2, 3, 4, 5};   
    // 2. The remaining elements are initialized to 0: {1, 2, 0, 0, 0}
    int arr[5] = {1, 2};            
    // 3. Uninitialized array, elements contain garbage values
    int arr[5];  
    // 4. All elements are initialized to 0
    int arr[5] = {}; 
    // 5. Uninitialized array
    int arr[5];  
    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;
    arr[3] = 40;
    arr[4] = 50;

```

### 2. Dynamic Array

```cpp
    // 1. Dynamically allocate an array of 5 integers
    int* arr = new int[5];  
    arr[0] = 1;
    arr[1] = 2;
    arr[2] = 3;
    arr[3] = 4;
    arr[4] = 5;

    // 2. Deallocate the dynamic array
    delete[] arr;  
```

### 3. 2DArray

```cpp
    int matrix[2][3] = {
                        {1, 2, 3}, 
                        {4, 5, 6}
                    };  // 2x3 matrix

```

### 4. C++11 Style Deduced size Initialization (List Initialization)

```cpp
    int arr[] = {10, 20, 30, 40};  // Size deduced automatically from the initializer list
```

### 5. std::array

```cpp
    #include <array>
    std::array<int, 5> arr = {1, 2, 3, 4, 5};  // std::array initialization
    
    // assign value like normal arrays
    arr[0] = 10;
    arr[1] = 20;


```

## Lvalue and Rvalue / pass by what

In C++, **pass by value** and **pass by reference** are two different methods for passing arguments to functions. To fully understand how these work, itâ€™s important to connect the concepts of **lvalue** and **rvalue**.

### 1. Lvalue vs. Rvalue
- **Lvalue (Left Value)**: Refers to an object that persists beyond a single expression. It's essentially a memory address or a variable you can assign to.
  
  Example:
  ```cpp
  int x = 10; // 'x' is an lvalue
  ```

- **Rvalue (Right Value)**: Refers to a temporary value or object that does not persist beyond the current expression. You cannot assign to an rvalue.
  
  Example:
  ```cpp
  int y = x + 5; // 'x + 5' is an rvalue (a temporary result)
  ```

### 2. Pass by Value
When passing by value, a **copy** of the argument is passed to the function. This means changes made to the parameter inside the function will not affect the original argument.

- **Behavior**: The function gets a copy of the original argument. Any modifications made to the parameter inside the function do not affect the original variable.
  
- Example of Pass by Value:

```cpp
void modify(int a) {
    a = 20; // This change only affects the local copy 'a', not the original argument
}

int main() {
    int x = 10;
    modify(x);  // x is passed by value, so 'x' remains 10
    std::cout << x;  // Output: 10
    return 0;
}
```

In this case, `x` is an **lvalue**, and the function `modify` receives a **copy** of `x` as its parameter. Modifying `a` inside the function has no effect on `x`.

- **rvalue in Pass by Value**: You can also pass an rvalue (temporary value) by value since itâ€™s copied to the function parameter.

```cpp
modify(5); // This works because the function will copy the value 5 to 'a'
```

### 3. Pass by Reference
When passing by reference, the function receives a **reference** to the original argument, allowing it to modify the original variable.

- **Behavior**: The function gets a reference to the original argument, so any changes made to the parameter inside the function will directly affect the original variable.

- Example of Pass by Reference (with lvalue):
```cpp
void modify(int& a) {
    a = 20; // This modifies the original argument
}

int main() {
    int x = 10;
    modify(x);  // x is passed by reference, so 'x' is modified to 20
    std::cout << x;  // Output: 20
    return 0;
}
```

In this case, `x` is an **lvalue** and is passed by reference, allowing the function to modify the original variable `x`.

- **rvalue in Pass by Reference**: You **cannot** pass an rvalue (like `5`) to a function that expects a regular lvalue reference (`int&`), because rvalues are temporary and do not have a persistent memory address.

```cpp
// This will cause an error:
modify(5);  // ERROR: Cannot bind rvalue to lvalue reference
```

### 4. Pass by Rvalue Reference (C++11 and Later)
C++11 introduced **rvalue references** (denoted by `&&`), which allow you to pass rvalues (temporary values) to functions by reference. This is useful in certain situations like implementing move semantics, which avoids copying large objects unnecessarily.

- **Behavior**: The function can "steal" the resources of a temporary object (rvalue) and reuse them, avoiding costly deep copies.

- Example of Pass by Rvalue Reference:

```cpp
void modify(int&& a) {
    a = 20;  // Modifies the temporary rvalue
}

int main() {
    modify(5);  // OK: rvalue (temporary value) is passed by rvalue reference
    return 0;
}
```

In this case, `5` is an **rvalue**, and the function `modify(int&&)` can take it as a reference, allowing you to modify the temporary value.

### Summary:

| **Concept**        | **lvalue**                             | **rvalue**                              |
|--------------------|----------------------------------------|-----------------------------------------|
| **Pass by Value**   | Copies the lvalue to the function.     | Copies the rvalue to the function.      |
| **Pass by Reference (`int&`)** | Modifies the original lvalue.             | Cannot bind rvalue to lvalue reference. |
| **Pass by Rvalue Reference (`int&&`)** | Not applicable, only for rvalue.      | Allows modifying the rvalue directly.   |

### **When to Use Each:**
- **Pass by Value**: Use when the function doesn't need to modify the original argument, and copying the argument is inexpensive.
- **Pass by Reference**: Use when the function needs to modify the original argument or when copying is expensive (e.g., large objects).
- **Pass by Rvalue Reference**: Use when you want to transfer ownership of a temporary objectâ€™s resources (e.g., in move semantics or when avoiding unnecessary copies).

Would you like to see more specific examples, such as how move semantics work with rvalue references?


## Lenght of Array and Vector
![LenSummary](../assets/cpp_len_001.png)
### 1. Len of Static Array
- total size of the array in bytes and then divide by the size of one element.

```cpp
    int arr[5] = {1, 2, 3, 4, 5};

    // Get the length of the array
    int length = sizeof(arr) / sizeof(arr[0]);

    std::cout << "Length of the array: " << length << std::endl;

```

- if you want to get the length of array of char, use std::strlen

```cpp
    const int max_size = 100;
    char str[max_size] = "stop";

    int length = std::strlen(str);
```


### 2. Len of a Dynamic Array (Allocated with new)
- For dynamic arrays allocated using new, the size information is not stored, and the sizeof operator will only give the size of the pointer, not the array. This means you need to manually keep track of the size when you allocate the array.

```cpp
    int* arr = new int[5];  // Dynamically allocate an array of 5 integers
    int length = 5;  // You need to track the length yourself

    std::cout << "Length of the dynamic array: " << length << std::endl;
    delete[] arr;  // Don't forget to free the memory
```

### 3. Length of std::array (C++11 and Later)
- If you are using std::array from C++11, you can use the .size() method to get the number of elements in the array.

```cpp
    #include <array>
    #include <iostream>

    std::array<int, 5> arr = {1, 2, 3, 4, 5};

    // Get the length of the std::array
    int length = arr.size();

    std::cout << "Length of the std::array: " << length << std::endl;
```

### 4. Length of std::vector

```cpp
    #include <vector>
    #include <iostream>

    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Get the length of the vector
    int length = vec.size();

    std::cout << "Length of the vector: " << length << std::endl;
```

## convert from Vector to Array
![ConvertSummary](../assets/cpp_convert_to_array_001.png)
### 1. Using &vector[0] 
- to Get a Pointer to the Underlying Array

```cpp
    #include <vector>
    #include <iostream>

    int main() {
        std::vector<int> vec = {1, 2, 3, 4, 5};

        // Get a pointer to the first element of the vector (C-style array)
        int* arr = &vec[0];  // or use vec.data()

        // Now you can use 'arr' as a C-style array
        for (int i = 0; i < vec.size(); ++i) {
            std::cout << arr[i] << " ";  // Output: 1 2 3 4 5
        }

        return 0;
    }
```

### 2. Using std::vector<T,Allocator>::data()
- This return `a pointer` which access the data of vector in the form of a pointer to `array`



### 2. Using std::copy 
- to Copy Vector Elements into a Static Array

```cpp
    #include <vector>
    #include <iostream>
    #include <algorithm>  // For std::copy

    int main() {
        std::vector<int> vec = {1, 2, 3, 4, 5};

        // Create a C-style array with the same size as the vector
        int arr[5];  // Make sure the size matches vec.size()

        // Copy elements from vector to array
        std::copy(vec.begin(), vec.end(), arr);

        // Now you can use 'arr' as a C-style array
        for (int i = 0; i < 5; ++i) {
            std::cout << arr[i] << " ";  // Output: 1 2 3 4 5
        }

        return 0;
    }

```

### 3. Dynamic Allocation 
- for Converting to a Dynamically Allocated Array

```cpp
    #include <vector>
    #include <iostream>

    int main() {
        std::vector<int> vec = {1, 2, 3, 4, 5};

        // Dynamically allocate an array with the same size as the vector
        int* arr = new int[vec.size()];

        // Copy elements from the vector to the array
        std::copy(vec.begin(), vec.end(), arr);

        // Use the dynamically allocated array
        for (size_t i = 0; i < vec.size(); ++i) {
            std::cout << arr[i] << " ";  // Output: 1 2 3 4 5
        }

        // Don't forget to free the dynamically allocated memory
        delete[] arr;

        return 0;
    }

```

### 4. Using std::array (C++11)

```cpp
    #include <vector>
    #include <array>
    #include <iostream>

    int main() {
        std::vector<int> vec = {1, 2, 3, 4, 5};

        // Create a std::array with the same size as the vector
        std::array<int, 5> arr;

        // Copy elements from vector to std::array
        std::copy(vec.begin(), vec.end(), arr.begin());

        // Now you can use 'arr' as a safer, fixed-size array
        for (int i = 0; i < arr.size(); ++i) {
            std::cout << arr[i] << " ";  // Output: 1 2 3 4 5
        }

        return 0;
    }
```

## Class

### Main

```cpp

#include <iostream>
#include <string>

#include "PhoneBook.h"

using namespace std;

int main()
{
    PhoneBook my_phonebook;

    ...

    return 0;
}
```

### header 

```cpp
#ifndef PHONE_BOOK_H_
#define PHONE_BOOK_H_

const int kMaxStr = 20; // ë¬¸ìì—´ì˜ ìµœëŒ€ ê¸€ì ìˆ˜

struct Contact
{
    char name[kMaxStr];
    char phone[kMaxStr];
};

class PhoneBook
{
public:
    PhoneBook();
    ~PhoneBook();

    bool IsEmpty();
    bool IsFull();
    void PrintAll();
    void PrintContact(int i);
    void AddContact();
    void AddContact(const char name[], const char phone[]);
    int FindByName();
    bool IsEqual(const char str1[], const char str2[]);
    void DeleteByName();

private:
    int capacity_ = 3; // ì—°ë½ì²˜ ìµœëŒ€ ê°œìˆ˜ (ë³€ê²½ ê°€ëŠ¥)
    int num_contacts_ = 0;
    Contact *contacts_ = nullptr;
};

#endif
```

### cpp file

```cpp
#include "PhoneBook.h"

#include <cassert>
#include <iostream>
#include <cstring> // memcpy(.)

using namespace std;

PhoneBook::PhoneBook()
{
    contacts_ = new Contact[capacity_];
}

PhoneBook::~PhoneBook()
{
    if (contacts_)
        delete[] contacts_;
}

bool PhoneBook::IsEmpty()
{
    assert(num_contacts_ >= 0);

    if (num_contacts_ == 0)
        return true;
    else
        return false;
}

bool PhoneBook::IsFull()
{
    if (num_contacts_ == capacity_)
        return true;
    else
        return false;
}

void PhoneBook::PrintAll()
{
    for (int i = 0; i < num_contacts_; i++)
    {
        PrintContact(i);
    }
}

void PhoneBook::PrintContact(int index)
{
    cout << index << " ";
    cout << contacts_[index].name;
    cout << ", " << contacts_[index].phone << endl;
}

void PhoneBook::AddContact(const char name[], const char phone[])
{
    assert(!IsFull()); // ë””ë²„ê¹…í•  ë•Œ assert ê´„í˜¸ ì•ˆìª½ ì¡°ê±´ì´ falseê°€ ë˜ë©´ ì˜¤ë¥˜ ì²˜ë¦¬

    memcpy(contacts_[num_contacts_].name, name, sizeof(contacts_[num_contacts_].name));
    memcpy(contacts_[num_contacts_].phone, phone, sizeof(contacts_[num_contacts_].phone));

    num_contacts_ += 1;
}

void PhoneBook::AddContact()
{
    // capacity_ê°€ ê³ ì •ëœ ê²½ìš°
    if (IsFull())
    {
        cout << "ë” ì´ìƒ ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤." << endl;
        return;
    }

    // ë” í•´ë³¼ ê²ƒ: ë©”ëª¨ë¦¬ë¥¼ ì¬í• ë‹¹ ë°›ì•„ì„œ ì—°ë½ì²˜ ê°œìˆ˜ ì œí•œ ì—†ì• ê¸°

    char new_name[kMaxStr];
    char new_phone[kMaxStr];

    cout << "ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš” : ";
    cin.getline(new_name, sizeof(new_name));

    cout << "ì „í™”ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš” : ";
    cin.getline(new_phone, sizeof(new_phone));

    AddContact(new_name, new_phone);
}

int PhoneBook::FindByName()
{
    char search_name[kMaxStr];

    cout << "ê²€ìƒ‰í•  ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš” : ";
    cin.getline(search_name, sizeof(search_name));

    // TODO: IsEqual(), PrintContact(i), return i

    cout << search_name << " ë‹˜ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤." << endl;

    return -1;
}

bool PhoneBook::IsEqual(const char str1[], const char str2[])
{
    for (int i = 0; i < kMaxStr; i++)
    {
        if (str1[i] != str2[i])
            return false;

        if (str1[i] == '\0')
            return true;
    }

    return true;
}

void PhoneBook::DeleteByName()
{
    // ì‚­ì œí•  ë•Œ ë©”ëª¨ë¦¬ë¥¼ ì¤„ì´ì§€ëŠ” ì•ŠëŠ” ê²ƒìœ¼ë¡œ í• ê»˜ìš”.

    int index = FindByName();

    if (index >= 0)
    {
        // TODO: ì¤‘ê°„ì—ì„œ ì‚­ì œí–ˆì„ ê²½ìš° ë°ì´í„° ì •ë¦¬

        // TODO: num_contacts_ í•˜ë‚˜ ê°ì†Œ

        num_contacts_ -= 1;
    }
}
```


## namespace

### âœ… ê¸°ë³¸ ë¬¸ë²•

- definition : 
    - `namespace`ëŠ” **ì´ë¦„(í•¨ìˆ˜, ë³€ìˆ˜, í´ë˜ìŠ¤ ë“±)ì˜ ì¶©ëŒì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” ê³µê°„ ë‹¨ìœ„**ì…ë‹ˆë‹¤.
    - > **"ì´ë¦„ë“¤ì„ ê·¸ë£¹ìœ¼ë¡œ ë¬¶ì–´ì£¼ëŠ” ìƒì"** > ì„œë¡œ ë‹¤ë¥¸ ê°œë°œìê°€ ê°™ì€ ì´ë¦„ì„ ì¨ë„ ì¶©ëŒí•˜ì§€ ì•Šë„ë¡ ë„ì™€ì£¼ëŠ” **ë²”ìœ„ ìŠ¤ì½”í”„ ë„êµ¬**


```cpp
namespace ì´ë¦„ {
    // ì—¬ê¸°ì— ë³€ìˆ˜, í•¨ìˆ˜, í´ë˜ìŠ¤ ë“±ì„ ì„ ì–¸
}
```

- ğŸ”§ ì˜ˆì œ

```cpp
namespace A {
    void sayHello() {
        std::cout << "Hello from A\n";
    }
}

namespace B {
    void sayHello() {
        std::cout << "Hello from B\n";
    }
}

int main() {
    A::sayHello();  // ì¶œë ¥: Hello from A
    B::sayHello();  // ì¶œë ¥: Hello from B
}
```


- âœ… ì£¼ìš” ëª©ì 

| ëª©ì                | ì„¤ëª…                                      |
| ---------------- | --------------------------------------- |
| **ì´ë¦„ ì¶©ëŒ ë°©ì§€**     | ì„œë¡œ ë‹¤ë¥¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ê°™ì€ ì´ë¦„ì˜ í•¨ìˆ˜/ë³€ìˆ˜ê°€ ìˆì–´ë„ ì•ˆì „      |
| **ì½”ë“œ êµ¬ì¡°í™”**       | ëª¨ë“ˆí™” ë° ë…¼ë¦¬ì ì¸ ê·¸ë£¹í•‘ ê°€ëŠ¥                       |
| **ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¤ê³„ì— í•„ìˆ˜** | í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬(STL)ëŠ” ì „ë¶€ `std` namespace ì•ˆì— ìˆìŒ |

---

### ì‚¬ìš© ë°©ë²• ìš”ì•½

- 1. **ì ‘ê·¼ ì‹œ ë²”ìœ„ ì—°ì‚°ì ì‚¬ìš©**

```cpp
MyNamespace::myFunction();
```

- 2. **`using`ìœ¼ë¡œ ìƒëµ ê°€ëŠ¥**
    - â— ë‹¨ì : ì „ì—­ì— ì´ë¦„ì„ í’€ì–´ë²„ë¦¬ë¯€ë¡œ ì¶©ëŒ ìœ„í—˜ ì¦ê°€

    ```cpp
    using namespace MyNamespace;
    myFunction();  // OK
    ```


- 3. **ì¤‘ì²© namespace**

```cpp
namespace A {
    namespace B {
        void func();
    }
}
// ë˜ëŠ” C++17ë¶€í„°
namespace A::B {
    void func();
}
```


- âœ… ì˜ˆì‹œ: ì „ì—­ ì¶©ëŒ ë°©ì§€

```cpp
// mathLib1
namespace Math {
    double sqrt(double x) { return x / 2; }  // ê°€ì§œ sqrt
}

// mathLib2
namespace OtherMath {
    double sqrt(double x) { return x * 0.5; }  // ë˜ ë‹¤ë¥¸ sqrt
}
```

â†’ `Math::sqrt(x)` ì™€ `OtherMath::sqrt(x)`ëŠ” ì„œë¡œ ì¶©ëŒí•˜ì§€ ì•ŠìŒ!

---



### ìµëª… namespace (íŒŒì¼ ë‚´ ì „ìš© ì˜ì—­)

- ë‚´ë¶€ êµ¬í˜„ ê°ì¶”ê¸°ì— ì¢‹ìŒ (`static` ë³€ìˆ˜ ëŒ€ì²´)

```cpp
namespace {
    int internalVar = 42;  // ì´ íŒŒì¼ ì•ˆì—ì„œë§Œ ì ‘ê·¼ ê°€ëŠ¥
}
```


---

### âœ… namespace vs class ìŠ¤ì½”í”„ ì°¨ì´

| êµ¬ë¶„       | namespace     | class                       |
| -------- | ------------- | --------------------------- |
| ëª©ì        | ì´ë¦„ êµ¬ë¶„         | ê°ì²´ ì„¤ê³„                       |
| í¬í•¨ ê°€ëŠ¥ ìš”ì†Œ | ë³€ìˆ˜, í•¨ìˆ˜, í´ë˜ìŠ¤ ë“± | ë©¤ë²„ ë³€ìˆ˜, ë©¤ë²„ í•¨ìˆ˜                |
| ì ‘ê·¼       | `MyNS::x`     | `MyClass::x` (ë˜ëŠ” ê°ì²´.member) |

---



## string formatting
![comparision](../assets/cpp_str_formatting_001.png)
### 1. std::stringstream

```cpp
    #include <iostream>
    #include <sstream>  // for std::stringstream
    #include <string>

    int main() {
        int age = 25;
        double height = 180.5;
        std::string name = "John";

        std::stringstream ss;
        ss << "Name: " << name << ", Age: " << age << ", Height: " << height << " cm";

        std::string formattedString = ss.str();  // ìŠ¤íŠ¸ë¦¼ ë‚´ìš©ì„ ë¬¸ìì—´ë¡œ ë³€í™˜
        std::cout << formattedString << std::endl;
        return 0;
    }
```  

### 2. std::format (C++ 20)

```cpp
    #include <iostream>
    #include <format>  // C++20 std::format
    #include <string>

    int main() {
        int age = 25;
        double height = 180.5;
        std::string name = "John";

        // std::formatì„ ì‚¬ìš©í•œ ë¬¸ìì—´ í¬ë§·íŒ…
        std::string formattedString = std::format("Name: {}, Age: {}, Height: {} cm", name, age, height);

        std::cout << formattedString << std::endl;

        return 0;
    }
```


### 3. sprintf 

```cpp
    #include <iostream>
    #include <cstdio>  // for sprintf
    #include <string>

    int main() {
        int age = 25;
        double height = 180.5;
        const char* name = "John";

        char buffer[100];  // ê²°ê³¼ë¥¼ ì €ì¥í•  ë²„í¼

        // sprintfë¥¼ ì‚¬ìš©í•œ í¬ë§·íŒ…
        std::sprintf(buffer, "Name: %s, Age: %d, Height: %.1f cm", name, age, height);

        std::cout << buffer << std::endl;

        return 0;
    }
```

### 4. std::to_string

```cpp
    #include <iostream>
    #include <string>

    int main() {
        int age = 25;
        double height = 180.5;
        std::string name = "John";

        // std::to_stringì„ ì‚¬ìš©í•œ í¬ë§·íŒ…
        std::string formattedString = "Name: " + name + ", Age: " + std::to_string(age) + ", Height: " + std::to_string(height) + " cm";

        std::cout << formattedString << std::endl;

        return 0;
    }
```


## std library

### std::strlen

- return the length of char array (not std::string)

```cpp
    const char str1[maxStr] = "stop1";
    char str2[maxStr] = "stop12";

    int len = sizeof(str1) / sizeof(str1[0]); // This is not suitable. because this is for the length of array

    const std::string str3 = "teststring";
    std::cout << std::strlen(str2) << std::endl;
    std::cout << str3.length() << "  /  " << str3.size() << std::endl;
```


### std::min
    - find the smallest number among three number
    
```cpp
// Using std::min to find the smallest number
    int smallest = std::min(num1, std::min(num2, num3));
```


### std::vector
- data()
    ```cpp
    #include <iostream>
    #include <vector>

    int main() {
        std::vector<float> myVec = {1.1f, 2.2f, 3.3f};

        float* ptr = myVec.data();  // í¬ì¸í„°ë¡œ ì ‘ê·¼

        for (size_t i = 0; i < myVec.size(); ++i) {
            std::cout << "myVec[" << i << "] = " << ptr[i] << std::endl;
        }

        return 0;
    }
    ```

- ğŸ“Œ data()ì™€ &vec[0]ì˜ ì°¨ì´ì ì€?

| êµ¬ë¶„	| ì„¤ëª… |
| ----- | ---- |
| vec.data() | ë²¡í„°ì˜ ë‚´ë¶€ ë°ì´í„°ë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ë¥¼ ì•ˆì „í•˜ê²Œ ë°˜í™˜ (ë¹„ì–´ ìˆì–´ë„ ì•ˆì „í•¨, íŠ¹íˆ C++17 ì´ìƒì—ì„œ) |
| &vec[0] | ì²« ë²ˆì§¸ ìš”ì†Œì˜ ì£¼ì†Œ. ë²¡í„°ê°€ ë¹„ì–´ ìˆì„ ê²½ìš° ì‚¬ìš©í•˜ë©´ undefined behavior(UB) ë°œìƒ ê°€ëŠ¥ |

- âœ… ë”°ë¼ì„œ vec.data()ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë” ì•ˆì „í•©ë‹ˆë‹¤.


ì¢‹ì•„ìš”! C/C++ì—ì„œ `memcpy()`ëŠ” ë©”ëª¨ë¦¬ë¥¼ ë‹¤ë£° ë•Œ ì•„ì£¼ ìì£¼ ì“°ì´ëŠ” í•¨ìˆ˜ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. ê·¸ë¦¬ê³  ì´ì™€ ê´€ë ¨ëœ ì—¬ëŸ¬ ë©”ëª¨ë¦¬ í•¨ìˆ˜ë“¤ë„ í•¨ê»˜ ì •ë¦¬í•´ ë“œë¦´ê²Œìš”.

---

## enum / enum class



- ì „í†µì ì¸ `enum`ì˜ íŠ¹ì§• (C ìŠ¤íƒ€ì¼ ì—´ê±°í˜•)

```cpp
enum Color {
    RED,
    GREEN,
    BLUE
};
```

- ë¬¸ì œì : **ê°’ì´ ì „ì—­ ë²”ìœ„(global scope)ì— ë…¸ì¶œë¨**
    - `RED`, `GREEN`, `BLUE`ëŠ” **ì „ì—­ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¡œ ë°”ë¡œ ë“¤ì–´ê°**
    - ì¦‰, **ì´ë¦„ ì¶©ëŒì´ ì‰½ê²Œ ë°œìƒ**í•˜ê³ ,
    - `enum`ë¼ë¦¬ **êµ¬ë¶„ ì—†ì´ í˜¼ìš©ë  ìˆ˜ ìˆëŠ” ìœ„í—˜**ì´ ìˆìŒ

```cpp
int RED = 123;

enum Color {
    RED,  // âš  ì—ëŸ¬ ë˜ëŠ” ì´ë¦„ ì¶©ëŒ
    GREEN,
    BLUE
};
```



- ìœ„í—˜ ì˜ˆì‹œ:
    - `UP`ì´ë¼ëŠ” ì´ë¦„ì´ **Directionê³¼ Status ëª¨ë‘ì— ëŒ€í•´ ìœ íš¨**í•œ ê²ƒì²˜ëŸ¼ ë³´ì„

```cpp
enum Direction { UP, DOWN };
enum Status { OK, FAIL };

Direction d = UP;    // OK
Status s = UP;       // âš  í‹€ë ¤ë„ ì»´íŒŒì¼ ê°€ëŠ¥. í˜¼ë™ ë°œìƒ
```

- `enum class`ì˜ íŠ¹ì§• (C++11 ì´í›„, **strongly scoped enum**)

```cpp
enum class Color {
    RED,
    GREEN,
    BLUE
};
```

- ì¥ì : **ê°’ì´ ì „ì—­ ë²”ìœ„ì— ë…¸ì¶œë˜ì§€ ì•ŠìŒ**

* `Color::RED`, `Color::GREEN` ë“± **ìŠ¤ì½”í”„ë¥¼ í†µí•´ ì ‘ê·¼**
* ë‹¤ë¥¸ enumê³¼ **ì´ë¦„ ì¶©ëŒ ì—†ìŒ**
* íƒ€ì…ì´ ëª…í™•í•˜ê³ , ì‹¤ìˆ˜ ë°©ì§€

- ì˜ˆì‹œ:

```cpp
enum class Direction { UP, DOWN };
enum class Status { OK, FAIL };

Direction d = Direction::UP;
// Status s = Direction::UP;  // âŒ ì»´íŒŒì¼ ì—ëŸ¬! íƒ€ì… ë‹¤ë¦„
```

- ì´ê²Œ ë°”ë¡œ í•µì‹¬:

> `enum`ì€ ì „ì—­ì— ê°’ì„ "í’€ì–´ë²„ë¦¬ì§€ë§Œ",
> `enum class`ëŠ” ê°’ì„ "ë¬¶ì–´ë‘ê³ " ì•ˆì „í•˜ê²Œ ê´€ë¦¬í•©ë‹ˆë‹¤.

-  ì–¸ì œ `enum`ì´ ìœ„í—˜í•´ì§€ë‚˜?

* í”„ë¡œì íŠ¸ê°€ ì»¤ì§€ê³ , ì—´ê±°í˜•ì´ ë§ì•„ì§ˆìˆ˜ë¡
* ë‹¤ë¥¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ë™ì¼í•œ `enum` ê°’ì´ ìˆì„ ë•Œ
* ë””ë²„ê¹… ì‹œ ì–´ë–¤ `enum`ì—ì„œ ë‚˜ì˜¨ ê°’ì¸ì§€ í˜¼ë™ë  ë•Œ


- ì •ë¦¬ ìš”ì•½ (ì „ì—­ ë²”ìœ„ ë…¸ì¶œì„ ì¤‘ì‹¬ìœ¼ë¡œ)

| í•­ëª©         | `enum` (ì „í†µì )       | `enum class` (í˜„ëŒ€ì )            |
| ---------- | ------------------ | ----------------------------- |
| ê°’ì˜ ìœ„ì¹˜      | ì „ì—­ ë²”ìœ„ë¡œ ë…¸ì¶œë¨ (`RED`) | enum ìŠ¤ì½”í”„ ë‚´ë¡œ ì œí•œ (`Color::RED`) |
| ì´ë¦„ ì¶©ëŒ ìœ„í—˜   | ë†’ìŒ                 | ì—†ìŒ                            |
| ëª…í™•í•œ íƒ€ì… ì²´í¬  | ì•½í•¨                 | ê°•í•¨ (íƒ€ì… ì•ˆì „)                    |
| ë™ì¼ ì´ë¦„ ì‚¬ìš©   | ë¶ˆê°€ëŠ¥                | ê°€ëŠ¥ (ìŠ¤ì½”í”„ê°€ ë‹¤ë¦„)                  |
| ì˜ë„í•˜ì§€ ì•Šì€ ë¹„êµ | í—ˆìš©                 | ê¸ˆì§€ë¨ (ë‹¤ë¥¸ enumë¼ë¦¬ ë¹„êµ ë¶ˆê°€)         |

---

- í•œ ì¤„ ìš”ì•½

> `enum class`ë¥¼ ì“°ë©´ **ì „ì—­ ë²”ìœ„ë¥¼ ë”ëŸ½íˆì§€ ì•Šê³ **,
> **ê° ê°’ë“¤ì´ ì†Œì†ëœ íƒ€ì… ì•ˆì—ë§Œ ì¡´ì¬**í•´ì„œ **ì•ˆì „í•˜ê³  ëª…í™•**í•˜ê²Œ ì½”ë”©í•  ìˆ˜ ìˆì–´ìš”.


ì¢‹ì•„ìš”!
ì´ë²ˆì—ëŠ” `enum class`ë¥¼ `switch`ë¬¸ê³¼ í•¨ê»˜ ì“°ëŠ” ë°©ë²•ê³¼, ê·¸ ê³¼ì •ì—ì„œ ìì£¼ ì‚¬ìš©ë˜ëŠ” `static_cast`ê¹Œì§€ í•¨ê»˜ ê¹”ë”í•˜ê²Œ ì„¤ëª…í•´ë“œë¦´ê²Œìš”.

---

### 1. `enum class`ì™€ `switch`ë¬¸ ì‚¬ìš© ë°©ë²•

- ê¸°ë³¸ `enum`ê³¼ ë‹¬ë¦¬, `enum class`ëŠ” **ë²”ìœ„ ìŠ¤ì½”í”„ê°€ ëª…í™•**í•˜ë¯€ë¡œ `switch`ë¬¸ì—ì„œ ê°’ì„ ë¹„êµí•˜ë ¤ë©´ ë°˜ë“œì‹œ **`EnumType::Value` í˜•ì‹ìœ¼ë¡œ ì ‘ê·¼**í•´ì•¼ í•©ë‹ˆë‹¤.


- ğŸ”§ ì˜ˆì‹œ ì½”ë“œ:

```cpp
#include <iostream>

enum class Status {
    OK,
    WARNING,
    ERROR
};

void printStatus(Status s) {
    switch (s) {
        case Status::OK:
            std::cout << "Everything is fine.\n";
            break;
        case Status::WARNING:
            std::cout << "There is a warning.\n";
            break;
        case Status::ERROR:
            std::cout << "An error occurred.\n";
            break;
    }
}
```

- ì£¼ì˜í•  ì :
    - `switch(s)`ì²˜ëŸ¼ `enum class` ê°’ì„ ë°›ì„ ìˆ˜ ìˆë‹¤.
    - **`case OK:`ì²˜ëŸ¼ ì“°ë©´ ì»´íŒŒì¼ ì—ëŸ¬ ë°œìƒ** â†’ `Status::OK`ì²˜ëŸ¼ **ì •í™•í•œ ë²”ìœ„ ì§€ì • í•„ìš”**

---

### 2. `static_cast`ë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ 

- C++ì˜ `enum class`ëŠ” **ê¸°ë³¸ì ìœ¼ë¡œ ì•”ë¬µì ì¸ ì •ìˆ˜í˜• ë³€í™˜ì´ ì•ˆ ë©ë‹ˆë‹¤**. ê·¸ë˜ì„œ ìˆ«ì ì—°ì‚°ì´ë‚˜ ì¶œë ¥ ë“±ì—ì„œ ì •ìˆ˜í˜•ìœ¼ë¡œ **ëª…ì‹œì  ë³€í™˜**ì„ í•´ì•¼ í•  ë•Œ `static_cast`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.


- ğŸ”§ ì˜ˆì‹œ: `enum class` â†’ `int`

```cpp
#include <iostream>

enum class Direction {
    LEFT = 0,
    RIGHT = 1,
    UP = 2,
    DOWN = 3
};

int main() {
    Direction dir = Direction::RIGHT;

    int value = static_cast<int>(dir);  // ëª…ì‹œì  ë³€í™˜
    std::cout << "Enum as int: " << value << std::endl;

    return 0;
}
```

- ì¶œë ¥:

```
Enum as int: 1
```

---

- ğŸ”§ ì˜ˆì‹œ: `int` â†’ `enum class`

```cpp
int user_input = 2;
Direction dir = static_cast<Direction>(user_input);

if (dir == Direction::UP) {
    std::cout << "Going up!\n";
}
```

âœ… ì´ì²˜ëŸ¼ enum classëŠ” **ê°•í•œ íƒ€ì… ê²€ì‚¬** ë•ë¶„ì—
íƒ€ì…ì„ ì •ìˆ˜ â†” ì—´ê±°í˜•ìœ¼ë¡œ ë³€í™˜í•  ë• ë°˜ë“œì‹œ `static_cast`ë¥¼ ì¨ì•¼ í•©ë‹ˆë‹¤.

---

### ì˜ˆì œ: í•©ì¹œ ì˜ˆì‹œ (`switch` + `static_cast`)

```cpp
#include <iostream>

enum class Menu {
    PLAY = 1,
    OPTIONS = 2,
    QUIT = 3
};

int main() {
    int choice;
    std::cout << "Enter your choice (1-3): ";
    std::cin >> choice;

    Menu selected = static_cast<Menu>(choice);

    switch (selected) {
        case Menu::PLAY:
            std::cout << "Starting game...\n";
            break;
        case Menu::OPTIONS:
            std::cout << "Opening options...\n";
            break;
        case Menu::QUIT:
            std::cout << "Quitting.\n";
            break;
        default:
            std::cout << "Invalid choice!\n";
    }

    return 0;
}
```


- âœ… ìš”ì•½

| í•­ëª©                       | ë‚´ìš©                                 |
| ------------------------ | ---------------------------------- |
| `enum class` in `switch` | `case EnumType::Value` í˜•ì‹ìœ¼ë¡œ ì¨ì•¼ í•¨   |
| `static_cast<Enum>(int)` | ì •ìˆ˜ë¥¼ enum classë¡œ ë°”ê¿€ ë•Œ               |
| `static_cast<int>(Enum)` | enum classë¥¼ ì •ìˆ˜ë¡œ ë°”ê¿€ ë•Œ               |
| ì•”ë¬µì  ë³€í™˜ í—ˆìš© ì—¬ë¶€             | âŒ `enum class`ëŠ” í—ˆìš© ì•ˆ í•¨ (ëª…ì‹œì  ë³€í™˜ í•„ìš”) |



- ê´€ë ¨ì£¼ì œ :
    - `enum class` ë‚´ë¶€ íƒ€ì… ì§€ì • (`enum class Status : uint8_t`)
    - `std::underlying_type` í™œìš©ë²•
    - `enum class`ë¥¼ ë¬¸ìì—´ë¡œ ì¶œë ¥í•˜ëŠ” ë°©ë²•




ì¢‹ì•„ìš”!
ì´ë²ˆì—ëŠ” C++ì—ì„œ ìì£¼ ë§ˆì£¼ì¹˜ëŠ” `extern`ê³¼ `inline` í‚¤ì›Œë“œì— ëŒ€í•´ **ì •ë¦¬ëœ í‘œì™€ ì˜ˆì‹œ ì¤‘ì‹¬**ìœ¼ë¡œ ê¹”ë”í•˜ê²Œ ì„¤ëª…í•´ë“œë¦´ê²Œìš”.

---

## `extern` vs `inline`

### `extern` í‚¤ì›Œë“œ

- **ì˜ë¯¸**:
    - `ë³€ìˆ˜` ë˜ëŠ” `í•¨ìˆ˜`ê°€ \*\*ë‹¤ë¥¸ íŒŒì¼ì— ì •ì˜ë˜ì–´ ìˆìœ¼ë©°, ì—¬ê¸°ì„  "ì„ ì–¸ë§Œ í•œë‹¤"\*\*ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.

- ìš©ë„:
    - **ì „ì—­ ë³€ìˆ˜ë‚˜ í•¨ìˆ˜**ë¥¼ **ì—¬ëŸ¬ ì†ŒìŠ¤ íŒŒì¼ì—ì„œ ê³µìœ **í•  ë•Œ ì‚¬ìš©
    - **ë‹¤ì¤‘ ì •ì˜ ë°©ì§€**

---

- ì‚¬ìš© ì˜ˆì‹œ:

    - **file1.cpp**

    ```cpp
    int globalVar = 42;  // ì‹¤ì œ ì •ì˜
    ```

    - file2.cpp**

    ```cpp
    extern int globalVar;  // ì„ ì–¸ë§Œ

    void printVar() {
        std::cout << globalVar << std::endl;  // ì‚¬ìš© ê°€ëŠ¥
    }
    ```

- `extern`ì€ "ë‹¤ë¥¸ ê³³ì— ì´ê±° ìˆì–´!" ë¼ê³  ì„ ì–¸ë§Œ í•´ì£¼ëŠ” ì—­í• ì…ë‹ˆë‹¤.


### `inline` í‚¤ì›Œë“œ

- ğŸ“Œ **ì˜ë¯¸**:
    - ì»´íŒŒì¼ëŸ¬ì—ê²Œ ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ëŒ€ì‹  **í•¨ìˆ˜ ì½”ë“œë¥¼ ê·¸ëŒ€ë¡œ ë³µì‚¬í•´ì„œ ì‚½ì…í•˜ë¼**ê³  "ì œì•ˆ"í•˜ëŠ” í‚¤ì›Œë“œì…ë‹ˆë‹¤.

- ğŸ“¦ ìš©ë„:
    - **ì§§ì€ í•¨ìˆ˜**ì— ì˜¤ë²„í—¤ë“œë¥¼ ì¤„ì´ê¸° ìœ„í•´ ì‚¬ìš©
    - **í—¤ë” íŒŒì¼ì— í•¨ìˆ˜ ì •ì˜ë¥¼ í¬í•¨ì‹œí‚¬ ë•Œ** ì»´íŒŒì¼ëŸ¬ê°€ ë‹¤ì¤‘ ì •ì˜ë¥¼ í”¼í•˜ë„ë¡ í•¨



- ì‚¬ìš© ì˜ˆì‹œ:

    - ì´ í•¨ìˆ˜ê°€ `square(5)`ë¡œ í˜¸ì¶œë˜ë©´ ì»´íŒŒì¼ íƒ€ì„ì— ê³„ì‚°í•¨í•¨

```cpp
inline int square(int x) {
    return x * x;
}
```




### inline í•¨ìˆ˜ì™€ í—¤ë” íŒŒì¼

```cpp
// myMath.h
#ifndef MYMATH_H
#define MYMATH_H

inline int add(int a, int b) {
    return a + b;
}

#endif
```

- `inline`ì„ ë¶™ì´ë©´ ì—¬ëŸ¬ ë²ˆ include ë˜ì–´ë„ **ë§í¬ ì—ëŸ¬ ì—†ì´ ì •ì˜ê°€ í—ˆìš©**ë©ë‹ˆë‹¤.


### ìš”ì•½ì•½

| í•­ëª©      | `extern`                    | `inline`                |
| ------- | --------------------------- | ----------------------- |
| ì—­í•       | ë‹¤ë¥¸ íŒŒì¼ì— ìˆëŠ” ê²ƒ ì„ ì–¸ë§Œ í•¨           | í˜¸ì¶œ ëŒ€ì‹  ì½”ë“œ ì‚½ì… ìš”ì²­          |
| ì ìš© ëŒ€ìƒ   | ë³€ìˆ˜, í•¨ìˆ˜                      | í•¨ìˆ˜                      |
| ì‚¬ìš© ìœ„ì¹˜   | `.cpp`ì—ì„œ ë‹¤ë¥¸ `.cpp` ë³€ìˆ˜/í•¨ìˆ˜ ì ‘ê·¼ | ì§§ì€ í•¨ìˆ˜ ì •ì˜ë¥¼ `.h` íŒŒì¼ì— ì“¸ ë•Œ  |
| ë‹¤ì¤‘ ì •ì˜ ì‹œ | âœ… ì„ ì–¸ë§Œ í•˜ë¯€ë¡œ OK                | âœ… ë§í¬ ì‹œ ì¤‘ë³µ ì •ì˜ ë°©ì§€         |
| ì†ë„ ì˜í–¥   | âŒ ì—†ìŒ                        | âœ… í˜¸ì¶œ ì˜¤ë²„í—¤ë“œ ì¤„ì¼ ìˆ˜ ìˆìŒ (ì¡°ê±´ë¶€) |

- `extern` ğŸ‘‰ "ì´ê±´ ë‹¤ë¥¸ íŒŒì¼ì— ìˆì–´!"
- `inline` ğŸ‘‰ "ì´ í•¨ìˆ˜ ì§§ìœ¼ë‹ˆê¹Œ í˜¸ì¶œ ë§ê³  ê·¸ëƒ¥ ì½”ë“œ ë³µë¶™í•´!"

### ì£¼ì˜í•  ì 

- `extern`ì€ **ì •ì˜ê°€ ë°˜ë“œì‹œ ì–´ë”˜ê°€ì— ìˆì–´ì•¼** í•¨. (ì•ˆ ê·¸ëŸ¬ë©´ **undefined reference** ì—ëŸ¬)
- `inline`ì€ **ì»´íŒŒì¼ëŸ¬ê°€ ë¬´ì¡°ê±´ ì¸ë¼ì¸í•´ì£¼ëŠ” ê±´ ì•„ë‹˜** (í•¨ìˆ˜ê°€ ë„ˆë¬´ í¬ë©´ ë¬´ì‹œë¨)
- C++ì—ì„œ `inline` í•¨ìˆ˜ëŠ” \*\*ODR(One Definition Rule)\*\*ì„ ìœ„ë°˜í•˜ì§€ ì•Šë„ë¡ í•´ì¤Œ â†’ í—¤ë”ì— ì—¬ëŸ¬ ë²ˆ í¬í•¨ë¼ë„ ë¬¸ì œ ì—†ìŒ

---


## ë©”ëª¨ë¦¬ ê´€ë ¨ í•¨ìˆ˜ë“¤

### memcpy 

```cpp
#include <cstring>  // or <string.h>

void* memcpy(void* dest, const void* src, std::size_t count);
```

- ì—­í• 
    - ë©”ëª¨ë¦¬ ë¸”ë¡ì„ **`src`ì—ì„œ `dest`ë¡œ `count` ë°”ì´íŠ¸ ë³µì‚¬**í•©ë‹ˆë‹¤.
    - **ë©”ëª¨ë¦¬ ë‚´ìš© ìì²´**ë¥¼ ê·¸ëŒ€ë¡œ ë°”ì´íŠ¸ ë‹¨ìœ„ë¡œ ë³µì‚¬í•©ë‹ˆë‹¤.

- ì‚¬ìš© ì˜ˆ

```cpp
#include <iostream>
#include <cstring>

int main() {
    char src[] = "Hello, world!";
    char dest[20];

    std::memcpy(dest, src, strlen(src) + 1);  // +1 to copy null terminator

    std::cout << "Copied: " << dest << std::endl;
    return 0;
}
```

    - ì¶œë ¥:

```
Copied: Hello, world!
```

---

- ì£¼ì˜
    - **`src`ì™€ `dest`ê°€ ê²¹ì¹˜ë©´(ë©”ëª¨ë¦¬ ì¤‘ì²©)** ë™ì‘ì´ ì •ì˜ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤ (undefined behavior).
    - ê·¸ëŸ° ê²½ìš°ì—” `memmove()`ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤ (ì•„ë˜ ì°¸ê³  ğŸ‘‡).


### ìì£¼ ì“°ì´ëŠ” ë©”ëª¨ë¦¬ ê´€ë ¨ í•¨ìˆ˜ë“¤ ì •ë¦¬

| í•¨ìˆ˜ëª… | ì„¤ëª… |
|--------|------|
| `memcpy(dest, src, size)` | **ë©”ëª¨ë¦¬ ë³µì‚¬ (ì¤‘ì²©âŒ)** |
| `memmove(dest, src, size)` | **ë©”ëª¨ë¦¬ ë³µì‚¬ (ì¤‘ì²© í—ˆìš©âœ…)** |
| `memset(ptr, value, size)` | **ë©”ëª¨ë¦¬ ì´ˆê¸°í™” (valueë¡œ sizeë§Œí¼ ì±„ì›€)** |
| `memcmp(ptr1, ptr2, size)` | **ë©”ëª¨ë¦¬ ë¹„êµ (ê°™ìœ¼ë©´ 0)** |
| `strlen(str)` | **ë¬¸ìì—´ ê¸¸ì´ ê³„ì‚° (`\0`ê¹Œì§€)** |
| `strcpy(dest, src)` | **ë¬¸ìì—´ ë³µì‚¬ (`\0` í¬í•¨)** |
| `strncpy(dest, src, n)` | **ë¬¸ìì—´ ë³µì‚¬ (në°”ì´íŠ¸ê¹Œì§€ë§Œ)** |

---

### 1. `memmove()`

```cpp
void* memmove(void* dest, const void* src, std::size_t count);
```

- `memcpy()`ì™€ ë¹„ìŠ·í•˜ì§€ë§Œ, **ì¤‘ì²©ëœ ë©”ëª¨ë¦¬ ì˜ì—­ë„ ì•ˆì „í•˜ê²Œ ë³µì‚¬** ê°€ëŠ¥

```cpp
char str[] = "abcdef";
std::memmove(str + 2, str, 4);  // ì•ˆì „í•˜ê²Œ ì´ë™ ê°€ëŠ¥
```

---

###  2. `memset()`

```cpp
void* memset(void* ptr, int value, std::size_t num);
```

- ë©”ëª¨ë¦¬ë¥¼ íŠ¹ì • ê°’ìœ¼ë¡œ ì´ˆê¸°í™”

```cpp
char buffer[100];
std::memset(buffer, 0, sizeof(buffer));  // ëª¨ë‘ 0ìœ¼ë¡œ ì´ˆê¸°í™”
```

---

### 3. `memcmp()`

```cpp
int memcmp(const void* ptr1, const void* ptr2, std::size_t num);
```

- ë‘ ë©”ëª¨ë¦¬ ë¸”ë¡ì˜ ë‚´ìš©ì„ ë¹„êµ
- ê²°ê³¼:
  - `0` â†’ ë™ì¼
  - `<0` â†’ `ptr1` < `ptr2`
  - `>0` â†’ `ptr1` > `ptr2`

```cpp
char a[] = "abc";
char b[] = "abc";
std::cout << memcmp(a, b, 3);  // ì¶œë ¥: 0
```

---

-  `memcpy()` vs `std::copy()`

| í•­ëª© | `memcpy()` | `std::copy()` |
|------|------------|---------------|
| í—¤ë” | `<cstring>` | `<algorithm>` |
| íƒ€ì… ì•ˆì •ì„± | ì—†ìŒ (void*) | ìˆìŒ (í…œí”Œë¦¿) |
| null í¬í•¨ | ë³µì‚¬í•¨ | ë¬´ê´€ |
| ì‚¬ìš© ìš©ë„ | Raw memory (byte-level) | íƒ€ì… ìˆëŠ” ì»¨í…Œì´ë„ˆ (e.g., vector) |

---

- ì‹¤ì „ì—ì„œ ì–¸ì œ ì“°ë‚˜?

| ìƒí™© | ì¶”ì²œ í•¨ìˆ˜ |
|------|-----------|
| ë°°ì—´ ë³µì‚¬ (char[], int[]) | `memcpy` or `std::copy` |
| ì¤‘ì²© ë³µì‚¬ ê°€ëŠ¥ì„± ìˆì„ ë•Œ | `memmove` |
| ë°°ì—´ ì´ˆê¸°í™” | `memset` |
| í¬ì¸í„° ë¹„êµ | `memcmp` |
| ë¬¸ìì—´ ì¡°ì‘ | `strcpy`, `strncpy`, `strlen` ë“± |

---

- ìš”ì•½

| í•¨ìˆ˜ | ì£¼ìš” ëª©ì  | ì¤‘ì²© í—ˆìš© | ì•ˆì „ì„± |
|------|-----------|------------|---------|
| `memcpy()` | ë¹ ë¥´ê³  ê°„ë‹¨í•œ ë©”ëª¨ë¦¬ ë³µì‚¬ | âŒ | ë¹ ë¦„, ìœ„í—˜í•  ìˆ˜ ìˆìŒ |
| `memmove()` | ì¤‘ì²© ê°€ëŠ¥ ë³µì‚¬ | âœ… | ì•ˆì „ |
| `memset()` | ë©”ëª¨ë¦¬ ì´ˆê¸°í™” | âœ… | ì•ˆì „ |
| `memcmp()` | ë©”ëª¨ë¦¬ ë‚´ìš© ë¹„êµ | âœ… | ì•ˆì „ |

---

- C++ì—ì„œëŠ” `std::vector`, `std::string`, `std::array`, `std::copy` ê°™ì€ **ê³ ìˆ˜ì¤€ ì»¨í…Œì´ë„ˆ/ì•Œê³ ë¦¬ì¦˜**ì´ ì œê³µë˜ì§€ë§Œ,  
**ì„±ëŠ¥ ë˜ëŠ” ì‹œìŠ¤í…œ í”„ë¡œê·¸ë˜ë° ì˜ì—­**ì—ì„œëŠ” `memcpy` ê³„ì—´ì´ ì—¬ì „íˆ ë§¤ìš° ìœ ìš©í•©ë‹ˆë‹¤.




## Additional Contents

### static_cast<type>

- 

### "\0" and '\0' are not same

- '\0' is the end of the array of char

### assert()

- ì‚¬ìš© ëª©ì  
    - ë””ë²„ê¹…ì„ ë„ì™€ì£¼ëŠ” í•¨ìˆ˜
- íŠ¹ì§• 
    - argumentë¡œ ë„£ì€ ì¡°ê±´ì‹ì´ falseì´ë©´ ë¬´ì¡°ê±´ ì¦‰ì‹œ ì¢…ë£Œ
    - ì¢…ë£Œëœê³³ì˜ ì¡°ê±´ ê³¼ íŒŒì¼ ê·¸ë¦¬ê³  ì¤„ë²ˆí˜¸ë¥¼ ì¶œë ¥í•´ì¤Œ

```cpp
#include <cassert>

assert(ì¡°ê±´ì‹);

```
