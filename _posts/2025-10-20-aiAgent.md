---
author: taiyeong.song
category: pipeline
layout: post
title: AI Agent
---

## Environments

### UV

#### How to install

- definition : module for managing project ! (better than pip, pyenv, poetry, virtualenv ...)
- [How to install](https://docs.astral.sh/uv/getting-started/installation/)

#### How to use

- Initialize a project

```batch
cd {directory}

// Create a folder named prj_name, and init uv under the folder
uv init {prj_name} 

// init uv at current folder
uv init 
```

- Fetch and setup other project dependencies

```batch
// Copy pyproject.toml file into your project folder
// And then,
uv sync # at the folder
```

- Add new package without pyproject.toml

```batch
uv add {package_name}
```

> **uv.lock File**
> - After setting up dependencies with `add` or `sync`, There might be a a file named uv.lock. And the file is designed to let system know the sub-dependencies of the main dependencies which are specidifed under pyproject.toml


### Jupyter

#### How to install

1. Install jupyter extension in vscode
2. Install ipykernel python module using `uv`

    ```batch
    // --dev argumnet is to install the module only for developer
    uv add ipykernel --dev
    ```

#### How to use

1. Create `.ipynb` file with main or with other name.
2. Select `venv` which is created by uv

## OpenAI Billing

- [OpenAI billing page](https://platform.openai.com/settings/organization)
- $30-$50 might be enough to move forward

## Set up project

1. Create folder
2. Initialize uv

    ```batch
    uv init
    ```

3. Copy `pyproject.toml` if it is provided.
4. Synchronize current project's dependencies with dipendencies which are specified pyproject.toml 

    - [Troubleshooting a case - OS error 396 when using OneDrive](https://github.com/astral-sh/uv/issues/7906)

    ```batch
    uv sync // if not in Onedrive
    uv sync --python 3.12 // crewai and other package have dependencies on python 3.12

    // If you're using OneDrive of Windows
    // 1. Not use hardlink
    uv sync --link-mode=copy # do not use hardlink 
    
    // 2. Clean cache and do sync
    uv cache clean
    uv sync
    ```

5. Set vscode's venv to uv's venv
6. Create `.env file` and add OPENAI_API_KEY (you can use any other name as env variable)

    ```python
    os.getenv("OPENAI_API_KEY") # it will return the key
    ```
7. Run a python code

    ```batch
    uv run {python_code}.py
    uv run --python 3.12 {python_code}.py
    ```


## Build your first AI response

- [a list of model that gpt need to be fed](https://platform.openai.com/docs/pricing)

- How to get response from `the selected model` by using `openai module`

```python

# Create client to link to openai
import openai
client = openai.OpenAI()

# Arguments
# - model : go to prcing page, and then choose one of the models
# - messages : a list of dict need to be fed into this argument
response = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[
        {
            "role" : "user",
            "content" : "How to build usd asset assembly in houdini ?",
        }
    ]
)

# Following that, just retrieve message from choice object
choice = response.choices[0]
choice.message.content
```

## AI Agent ! what is that ?

- Definition : A system that handle with question or problem on behalf of user
- And, AI Agent is an AI, when user asks 

    ```python
    """
    I have the following functions in my system.

    `get_weather`
    `get_currency`
    `get_news`

    All of them receive the name of a country as an argument (i.e get_news('spain'))

    Please answer with the name of the function that you would like me to run.

    Please say nothing else, just the name of the function with the arguments.

    Answer the following question:

    What is the weather in Greece ?
    """
    ```
- not ask
    ```python
    """
    How to get a weather in Greece by using functions below ?
        `get_weather`
        `get_currency`
        `get_news`
    """
    ```

- if so, it returns 
    - ![answer01](/assets/AIAgent/what_is_aiAgent_01.png)
    - instead of 
        ```
        "To get the weather in Greece using a hypothetical `get_weather` function, you would typically follow these steps:\n\n1. **Check Parameters Required**: Understand what parameters the `get_weather` function accepts. Common parameters might include the location (in this case, Greece), the date for which you want the weather, and perhaps the type of data you need (current weather, forecast, etc.).\n\n2. **Call the Function**: Use the `get_weather` function with the appropriate arguments.\n\nHereâ€™s a simple example in Python (assuming these functions are provided in a package or module):\n\n```python\n# Example of fetching weather in Greece\n\n# Assume these functions are defined in a module named 'weather_api'\nfrom weather_api import get_weather\n\n# Get current weather in Greece\ngreece_weather = get_weather(location='Greece')\n\n# Output the weather\nprint(greece_weather)\n```\n\n### Example Output\nThe output might be a dictionary or an object with weather details such as temperature, humidity, condition (sunny, rainy, etc.).\n\n### Additional Options\nIf you want to retrieve related information, you could also use the `get_currency` and `get_news` functions in a similar manner:\n\n```python\n# Example of fetching currency and news related to Greece\n\n# Get the currency information\nfrom finance_api import get_currency\n\ngreece_currency = get_currency(country='Greece')\nprint(greece_currency)\n\n# Get news related to Greece\nfrom news_api import get_news\n\ngreece_news = get_news(topic='Greece')\nprint(greece_news)\n```\n\n### Summary\n- Use `get_weather` to fetch weather data for Greece.\n- Use `get_currency` to fetch currency details (like the Euro).\n- Use `get_news` to get the latest news related to Greece.\n\nBe sure to check the documentation for the specific API or library you're using to understand the exact function signatures and available parameters!"
        ```
- `Prompt` is really important !

## Adding memory
- Goal : How to make the Ai `remember` previous answers
- Problem ! : With the code above - [Build your first AI response](#build-your-first-ai-response), it will not remember user's previous question like
    ```text
    user : My name is Taiyeong
    AI : Hi Taiyeong, what can I help you?
    user : what is my name
    AI : Sorry...
    ```
- Solution : Append user input (str) and AI reponse (str or object) to `list` or other type of variable

    ```python
    msg_stack = []

    # Ask question to ai
    msg_stack.append({"role":"user", "content":user_msg})
    response = client.chat.completions.create(model="gpt-4o-mini", messages=msg_stack)

    # After that, append the answer to the message stack 
    answer = response.choices[0].message.content
    msg_stack.append({"role":"assistant", "content":answer})

    # Get another question
    msg_stack.append({"role":"user", "content":user_msg})
    ```
    
    - Fianl code

    ```python
    from typing import List
    import openai
    client = openai.OpenAI()

    def call_ai(msg_stack :List[dict]) -> str:
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=msg_stack
        )
        answer = "Sorry, I didn't get it. Can you explan more detail ? "
        if response:
            answer = response.choices[0].message.content
        msg_stack.append(
                {"role":"assistant", "content":answer}
            )
        return answer


    msg_stack = []
    while True:
        user_msg = input("Send a message to the LLM...")
        if user_msg == "quit" or user_msg == "q":
            print(f"Ai Answer : Ok, I will close this conversation now, but if you need any help, feel free to reach out to me :)")
            break
        else:
            msg_stack.append(
                {"role":"user", "content":user_msg}
            )
            answer_from_ai = call_ai(msg_stack)
            print(f"User ask : {user_msg}")
            print(f"Ai Answer : {answer_from_ai}")
    ```

## Adding Tools 

- Goal : Make the Ai give purpose-oriented answer in terms of coding
    - not text-based answer but `answer based on api documents`

- How to ? - tools=TOOLS / "role": "tool" / "tool_call_id": tool_call.id / "tool_calls" ...
    1. Give tool schema to the ai
    2. Check if `response.choice[0].message.content` is None or not - it means the answer used tools and tools mapping
    3. Check `response.choice[0].message.tool_calls`. And then, give feedbacks to the ai
        - Append feedback two times
            1. functions and arguments that ai gave us
            2. returns that functions returned after running the functions
    - Register functions - Check `FUNCTION_MAP` variable below

```python
from openai.types.chat import ChatCompletionMessage


def get_weather(city):
    return "33 degrees celcius."


FUNCTION_MAP = {
    "get_weather": get_weather,
}


def process_ai_response(message: ChatCompletionMessage):

    if message.tool_calls:
        messages.append(
            {
                "role": "assistant",
                "content": message.content or "",
                "tool_calls": [
                    {
                        "id": tool_call.id,
                        "type": "function",
                        "function": {
                            "name": tool_call.function.name,
                            "arguments": tool_call.function.arguments,
                        },
                    }
                    for tool_call in message.tool_calls
                ],
            }
        )

        for tool_call in message.tool_calls:
            function_name = tool_call.function.name
            arguments = tool_call.function.arguments

            print(f"Calling function: {function_name} with {arguments}")

            try:
                arguments = json.loads(arguments)
            except json.JSONDecodeError:
                arguments = {}

            function_to_run = FUNCTION_MAP.get(function_name)

            result = function_to_run(**arguments)

            print(f"Ran {function_name} with args {arguments} for a result of {result}")

            messages.append(
                {
                    "role": "tool",
                    "tool_call_id": tool_call.id,
                    "name": function_name,
                    "content": result,
                }
            )

        call_ai()
    else:
        messages.append({"role": "assistant", "content": message.content})
        print(f"AI: {message.content}")


def call_ai():
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=messages,
        tools=TOOLS,
    )
    process_ai_response(response.choices[0].message)
```

## CrewAI

### Terminolgoy
- crew : a group of agents
- agent : it is a thing that help user get answer based on purpose of question
- task : task is task

### Basic workflow of CrewAI

- Use decorators : CrewBase / agent / task / crew
    - There are three parts - **main.py / tools.py / agents.yaml and tasks.yaml**
    - **The CrewBase decorator collects agents and tasks automatically**

#### Main.py
- This main code feed yaml files and tools.py

    ```python
    import dotenv

    dotenv.load_dotenv()

    from crewai import Crew, Agent, Task
    from crewai.project import CrewBase, agent, task, crew
    from tools import count_letters


    @CrewBase
    class TranslatorCrew:

        @agent
        def translator_agent(self):
            return Agent(
                config=self.agents_config["translator_agent"],
            )

        # This agent is using `tools`
        @agent
        def counter_agent(self):
            return Agent(
                config=self.agents_config["counter_agent"],
                tools=[count_letters],
            )

        @task
        def translate_task(self):
            return Task(
                config=self.tasks_config["translate_task"],
            )

        @task
        def retranslate_task(self):
            return Task(
                config=self.tasks_config["retranslate_task"],
            )

        @task
        def count_task(self):
            return Task(
                config=self.tasks_config["count_task"],
            )

        @crew
        def assemble_crew(self):
            return Crew(
                agents=self.agents,
                tasks=self.tasks,
                verbose=True,
            )


    TranslatorCrew().assemble_crew().kickoff(
        inputs={
            "sentence": "I'm Nico and I like to ride my bicicle in Napoli",
        }
    )
    ```

#### yaml files : how crewai use yaml files which are under config folder
- The folder name for these yaml file must be `config`
    - ![config_folder](/assets/AIAgent/config_for_agents_and_tasks.png)

- agents.yaml
    - [Crewai Agent attributes](https://docs.crewai.com/en/concepts/agents)

    ```yaml
    translator_agent:
        role: >
            Translator to translate from English to Italian
        goal: >
            To be a good and useful translator to avoid misunderstandings.
        backstory: >
            You grew up between New York and Palermo, you can speak two languages fluently, and you can detect the cultural differences.
    counter_agent:
        role: >
            To count the lenght of things.
        goal: >
            To be a good counter that never lies or makes things up.
        backstory: >
            You are a genius counter.
    ```

- tasks.yaml
    - [Crewai tasks attributes](https://docs.crewai.com/en/concepts/tasks)

    ```yaml
        translate_task:
            description: >
                Translate {sentence} from English to Italian without making mistakes.
            expected_output: >
                A well formatted translation from English to Italian using proper capitalization of names and places.
            agent: translator_agent

        retranslate_task:
            description: >
                Translate {sentence} from Italian to Greek without making mistakes.
            expected_output: >
                A well formatted translation from Italian to Greek using proper capitalization of names and places.
            agent: translator_agent

        count_task:
            description: >
                Count the amount of letters in a sentence.
            expected_output: >
                The number of letters in a sentence.
            agent: counter_agent
    ```

#### tools.py : how crewai use tools 
- Crewai has its own tools
    - [Crewai's tools](https://docs.crewai.com/en/tools/overview)
    - ![Crewai tools](/assets/AIAgent/crewai_tools.png)

- How to use user-defined-tools
    1. Create a function and add `tool` decorator for the function

        ```python
        from crewai.tools import tool


        @tool
        def count_letters(sentence: str):
            """
            This function is to count the amount of letters in a sentence.
            The input is a `sentence` string.
            The output is a number.
            """
            print("tool called with input:", sentence)
            return len(sentence)
        ```

    2. **yaml files** . Add specific `instruction` into `agents.yaml` and `tasks.yaml`

        - agents.yaml

            ```yaml
            counter_agent:
                role: >
                    To count the lenght of things.
                goal: >
                    To be a good counter that never lies or makes things up.
                backstory: >
                    You are a genius counter.
            ```
        
        - tasks.yaml

            ```yaml
            count_task:
                description: >
                    Count the amount of letters in a sentence.
                expected_output: >
                    The number of letters in a sentence.
                agent: counter_agent
            ```
    3. **Decorated functions** . Create `an agent function` and `a task function`

        ```python
            from tools import count_letters

            @CrewBase
            class TranslatorCrew:
                # ... 
                @agent
                def counter_agent(self):
                    return Agent(
                        config=self.agents_config["counter_agent"],
                        tools=[count_letters],
                    )

                @task
                def count_task(self):
                    return Task(
                        config=self.tasks_config["count_task"],
                    )
                # ...
        ```


## CrewAI 01: News Reader Agent

### Properties of two yaml files

#### Date / LLM / Markdown /  Output file / Create Directory

- Within the title, I'd write down ...
    - agetns.yaml
        - ![agent_properties](/assets/AIAgent/llm_property.png)
        - `inject_date` property : bool
        - `llm` property : str
    - tasks.yaml
        - ![task_properties](/assets/AIAgent/tast_properties.png)
        - `markdown` property : bool
        - `output_file` property
        - `create_directory` property

### SerperDevTool / playwright - sync_playwright / BeautifulSoup

- By using those modules, `Create tools` with tool decorator
- And, use the tools in main.py for an agent method


#### SuperDevTool

- Definition
    - A tool for searching something from Goolge, created by CrewAI
    - Example

        ```python
        from crewai_tools import SerperDevTool

        tool = SerperDevTool()

        result = tool.run(search_query="ChatGPT")
        print(result)
        ```

#### Playwright

- Definition
    - Created by Microsoft
    - Opensource browser automating library
    - Allow user to control Chrominum.Firefox.WebKit
    - Use for web-testing, web-scrapping, UI-automation ...

#### `Sync` vs `Async`, provided by Playwright

- PlaywrightëŠ” ë‘ ê°€ì§€ API ìŠ¤íƒ€ì¼ì„ ì œê³µí•´ìš”:

    | API ìŠ¤íƒ€ì¼ | ëª¨ë“ˆ | íŠ¹ì§• |
    |-----------|------|------|
    | **ë™ê¸°(Sync)** | `playwright.sync_api` | ì¼ë°˜ì ì¸ Python ì½”ë“œì²˜ëŸ¼ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰ë¨ |
    | **ë¹„ë™ê¸°(Async)** | `playwright.async_api` | `async/await` ê¸°ë°˜, ê³ ì„±ëŠ¥ ë³‘ë ¬ ì‘ì—… ê°€ëŠ¥ |

    - **ë™ê¸° APIëŠ” ì§ê´€ì ì´ê³  ë””ë²„ê¹…ì´ ì‰¬ì›Œì„œ** ë¹ ë¥´ê²Œ ì‘ì—…í•˜ê¸° ì¢‹ì•„ìš”.


- ğŸ­ `playwright.sync_api` ì™€ `sync_playwright`ë€?

    - `playwright.sync_api`ëŠ” **Playwrightì˜ ë™ê¸°(Synchronous) API ë²„ì „**ì„ ì œê³µí•˜ëŠ” ëª¨ë“ˆì´ì—ìš”.`sync_playwright`ëŠ” **Playwrightë¥¼ ë™ê¸° ë°©ì‹ìœ¼ë¡œ ì‹¤í–‰í•˜ê¸° ìœ„í•œ ì—”íŠ¸ë¦¬ í¬ì¸íŠ¸ í•¨ìˆ˜**ì…ë‹ˆë‹¤.


    - ğŸš€ ê¸°ë³¸ ì‚¬ìš© ì˜ˆì‹œ

        ```python
        from playwright.sync_api import sync_playwright

        with sync_playwright() as p:
            browser = p.chromium.launch()
            page = browser.new_page()
            page.goto("https://playwright.dev")
            print(page.title())
            browser.close()
        ```
        
        1. Playwright ì‹¤í–‰
        2. Chromium ë¸Œë¼ìš°ì € ì‹¤í–‰
        3. ìƒˆ í˜ì´ì§€ ì—´ê¸°
        4. íŠ¹ì • URLë¡œ ì´ë™
        5. í˜ì´ì§€ ì œëª© ì¶œë ¥
        6. ë¸Œë¼ìš°ì € ì¢…ë£Œ


- `playwright.async_api`
    - Large-scale crawling

        ```python
        import asyncio
        import aiohttp
        from bs4 import BeautifulSoup

        class Crawler:
            def __init__(self, max_workers=20, max_concurrency=5):
                self.queue = asyncio.Queue()
                self.semaphore = asyncio.Semaphore(max_concurrency)
                self.max_workers = max_workers

            async def fetch(self, session, url):
                async with self.semaphore:
                    async with session.get(url) as resp:
                        return await resp.text()

            async def worker(self, session):
                while True:
                    try:
                        url = await asyncio.wait_for(self.queue.get(), timeout=3)
                    except asyncio.TimeoutError:
                        return

                    html = await self.fetch(session, url)
                    await self.parse(html)
                    self.queue.task_done()

            async def parse(self, html):
                soup = BeautifulSoup(html, "html.parser")
                # ë°ì´í„° ì¶”ì¶œ ë° ì €ì¥ ë¡œì§
                pass

            async def run(self, start_urls):
                async with aiohttp.ClientSession() as session:
                    for url in start_urls:
                        await self.queue.put(url)

                    workers = [
                        asyncio.create_task(self.worker(session))
                        for _ in range(self.max_workers)
                    ]

                    await self.queue.join()

                    for w in workers:
                        w.cancel()

        asyncio.run(Crawler().run(["https://example.com"]))
        ```